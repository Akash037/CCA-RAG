name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  SERVICE_NAME: rag-system
  REGION: us-central1

jobs:
  # Code Quality Checks
  quality:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        virtualenvs-create: true
        virtualenvs-in-project: true
        installer-parallel: true
    
    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v3
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
    
    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --no-root
    
    - name: Install project
      run: poetry install --no-interaction
    
    - name: Run Black
      run: poetry run black --check .
    
    - name: Run isort
      run: poetry run isort --check-only .
    
    - name: Run flake8
      run: poetry run flake8 .
    
    - name: Run mypy
      run: poetry run mypy app/

  # Unit Tests
  test:
    runs-on: ubuntu-latest
    needs: quality
    
    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        virtualenvs-create: true
        virtualenvs-in-project: true
        installer-parallel: true
    
    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v3
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
    
    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --no-root
    
    - name: Install project
      run: poetry install --no-interaction
    
    - name: Create test database
      run: mkdir -p data && touch data/test.db
    
    - name: Run tests
      env:
        DATABASE_URL: sqlite+aiosqlite:///./data/test.db
        REDIS_URL: redis://localhost:6379/1
        ENVIRONMENT: test
      run: poetry run pytest
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  # Security Scan
  security:
    runs-on: ubuntu-latest
    needs: quality
    steps:
    - uses: actions/checkout@v4
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Build Docker Image
  build:
    runs-on: ubuntu-latest
    needs: [test, security]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Configure Docker to use gcloud as credential helper
      run: |
        gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev
    
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v1
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v1
    
    - name: Build and push Docker image
      run: |
        # Build image
        docker build -t ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/rag-system/${{ env.SERVICE_NAME }}:${{ github.sha }} .
        docker build -t ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/rag-system/${{ env.SERVICE_NAME }}:latest .
        
        # Push image
        docker push ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/rag-system/${{ env.SERVICE_NAME }}:${{ github.sha }}
        docker push ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/rag-system/${{ env.SERVICE_NAME }}:latest

  # Deploy to Cloud Run (Production)
  deploy-production:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v1
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v1
    
    - name: Deploy to Cloud Run
      run: |
        gcloud run deploy ${{ env.SERVICE_NAME }} \
          --image ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/rag-system/${{ env.SERVICE_NAME }}:${{ github.sha }} \
          --platform managed \
          --region ${{ env.REGION }} \
          --allow-unauthenticated \
          --memory 2Gi \
          --cpu 2 \
          --min-instances 0 \
          --max-instances 10 \
          --timeout 300 \
          --concurrency 80 \
          --set-env-vars ENVIRONMENT=production \
          --set-env-vars DATABASE_URL=${{ secrets.DATABASE_URL }} \
          --set-env-vars REDIS_URL=${{ secrets.REDIS_URL }} \
          --set-env-vars GOOGLE_CLOUD_PROJECT=${{ secrets.GCP_PROJECT_ID }} \
          --set-env-vars VERTEX_AI_LOCATION=${{ secrets.VERTEX_AI_LOCATION }} \
          --set-env-vars RAG_DOCUMENT_CORPUS_ID=${{ secrets.RAG_DOCUMENT_CORPUS_ID }} \
          --set-env-vars RAG_MEMORY_CORPUS_ID=${{ secrets.RAG_MEMORY_CORPUS_ID }} \
          --set-env-vars GOOGLE_DRIVE_FOLDER_ID=${{ secrets.GOOGLE_DRIVE_FOLDER_ID }} \
          --set-env-vars GOOGLE_SHEETS_SPREADSHEET_ID=${{ secrets.GOOGLE_SHEETS_SPREADSHEET_ID }} \
          --set-env-vars SECRET_KEY=${{ secrets.SECRET_KEY }}
    
    - name: Get service URL
      run: |
        SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} --region ${{ env.REGION }} --format 'value(status.url)')
        echo "Service deployed at: $SERVICE_URL"
        echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_ENV
    
    - name: Run health check
      run: |
        sleep 30  # Wait for service to be ready
        curl -f ${{ env.SERVICE_URL }}/health || exit 1

  # Deploy to Cloud Run (Staging)
  deploy-staging:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop'
    environment: staging
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v1
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v1
    
    - name: Deploy to Cloud Run (Staging)
      run: |
        gcloud run deploy ${{ env.SERVICE_NAME }}-staging \
          --image ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/rag-system/${{ env.SERVICE_NAME }}:${{ github.sha }} \
          --platform managed \
          --region ${{ env.REGION }} \
          --allow-unauthenticated \
          --memory 1Gi \
          --cpu 1 \
          --min-instances 0 \
          --max-instances 5 \
          --timeout 300 \
          --concurrency 40 \
          --set-env-vars ENVIRONMENT=staging \
          --set-env-vars DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }} \
          --set-env-vars REDIS_URL=${{ secrets.STAGING_REDIS_URL }} \
          --set-env-vars GOOGLE_CLOUD_PROJECT=${{ secrets.GCP_PROJECT_ID }} \
          --set-env-vars VERTEX_AI_LOCATION=${{ secrets.VERTEX_AI_LOCATION }} \
          --set-env-vars RAG_DOCUMENT_CORPUS_ID=${{ secrets.STAGING_RAG_DOCUMENT_CORPUS_ID }} \
          --set-env-vars RAG_MEMORY_CORPUS_ID=${{ secrets.STAGING_RAG_MEMORY_CORPUS_ID }} \
          --set-env-vars SECRET_KEY=${{ secrets.SECRET_KEY }}

  # Integration Tests
  integration-tests:
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/develop'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Poetry
      uses: snok/install-poetry@v1
    
    - name: Install dependencies
      run: poetry install --no-interaction
    
    - name: Get staging service URL
      run: |
        gcloud auth activate-service-account --key-file <(echo '${{ secrets.GCP_SA_KEY }}')
        SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }}-staging --region ${{ env.REGION }} --format 'value(status.url)')
        echo "STAGING_URL=$SERVICE_URL" >> $GITHUB_ENV
    
    - name: Run integration tests
      env:
        SERVICE_URL: ${{ env.STAGING_URL }}
      run: poetry run pytest tests/integration/ -v

  # Notify on deployment
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-production, deploy-staging]
    if: always() && (needs.deploy-production.result == 'success' || needs.deploy-staging.result == 'success')
    
    steps:
    - name: Notify deployment success
      run: |
        if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
          echo "✅ Production deployment successful"
        fi
        if [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
          echo "✅ Staging deployment successful"
        fi
